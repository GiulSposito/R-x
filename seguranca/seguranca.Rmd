---
title: "O Rio de Janeiro ficou mais violento comparado a outras cidades?"
output:
  html_document:
    df_print: paged
---

Todos acompanharam as notícias de intervenção no Rio de Janeiro recentemente, sobre o pretesto que das escalada da violência e criminalidade na cidade. Mas será que o Rio de Janeiro ficou de fato mais violento? E comparado a outras cidades, ela é proporcional ou diferente do que acontece em outras cidades do Brasil? Usaremos esse tema para exercitar análises de dados usando dados disponíveis em sites públicos.

<!-- more --> 

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# setup
library(knitr)

# default behavior for chunks
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(cache = TRUE)
```


## Pré-requisitos

Para se analisar dados de violência e criminalidade dois dados são necessários:

1. Número de Ocorrências Policiais
2. População do Município

Não podemos analisar somente o número de ocorrências, pois se espera que cidades com mais habitantes possuam mais ocorrências, então é necessário analisar as taxas (ocorrências/população), mas isso também não é suficiente. Também espara-se que cidades com patamares populacionais diferentes, tenham atratividades economicas diferentes e portanto índices de criminalidade distintos, por exemplo, não se pode comparar diretametne taxas de criminalidade de uma cidade com 100 mil habitantes com São Paulo, BH ou Rio, que possuem milhões de habitantes.

## Dados

Duas fontes de dados possíveis veem a mente quando se trata de população e ocorrências policiais: [IBGE](https://www.ibge.gov.br/) e [Ministério da Justiça](http://justica.gov.br/), respectivamente.

### População

O site do [IBGE](https://www.ibge.gov.br) é bem abrangente, há muita informação, tanto para busca manual como para [APIs](https://servicodados.ibge.gov.br/api/docs), para vários indicadores economicos e sociais (mas curiosamente não há sobre criminalidade e ocorrências policiais). Navegando pela estrutura buscando pela informação de população dos municípios, a maneira mais rápida de se conseguir os números encontradas foi fazendo a consulta via [SIDRA](https://sidra.ibge.gov.br/) (Sistema IBGE de Recuperação Automática, que permite buscar várias estatísticas e indicadores) e consultando pela _população residente estimada_ por _unidade territorial_ (que pode ser região, estado ou município). [Feita a consulta](https://sidra.ibge.gov.br/tabela/6579) você pode baixar o CSV (_tabela6579.csv_) para importar.

Os dados vêem consolidados por unidade territorial (que pode ser estado ou municipio) e por ano.

```{r readPopCSV, cache=TRUE}
# setup 
library(tidyverse)
library(lubridate)

# lendo dados da populacao populacao
read.table("./data/tabela6579.csv",
           sep = ";",
           skip=3, # ha duas linhas iniciais com comentarios
           nrows = 83955,
           encoding = "UTF-8",
           stringsAsFactors = F,
           header = F) %>% # nao importaremos o header
  # Definindo o header manualmente (ele tem acentos no CSV)
  setNames(c("nivel","cod.ibge","municipio","num","ano","populacao")) %>%
  # o numero do registro nao interessa
  select(-num) %>% 
  # populacao foi importada como "string", ajustando para inteiro
  mutate(populacao=as.integer(populacao)) %>% 
  # definindo que o número da populacao para um ano X eh a sua medida em dezembro
  mutate(date = ymd(paste0(ano,"/12/01"))) %>%
  as.tibble() -> pop

head(pop)

```

### Ocorrências

Já uma base nacional de ocorrências policiais foi encontrada no site do [Ministério da Justiça](http://justica.gov.br/), que na época desta análise ainda era Ministério da Justiça e Segurança Pública. A base consolidada esta mais especificamente no [SINESPJC](http://dados.mj.gov.br/dataset/sistema-nacional-de-estatisticas-de-seguranca-publica) - sistema Nacional de Estatísticas de Segurança Pública e Justiça Criminal.

Entretanto os dados na página estão separados em arquivos tipo CSV por ano. Cada link leva a uma página que exibe os dados e também um link para download

Será então necessário fazer um _data scrapping_ para pegar cada um das páginas e então obter o link do CSV nela para fazer o download.

```{r mjDataScrappnig, cache=TRUE, eval=FALSE}
# pacote de data scrapping
library(rvest)

# url que lista as páginas de estatistica
base.url <- "http://dados.mj.gov.br"
stat.list <- "/dataset/sistema-nacional-de-estatisticas-de-seguranca-publica"

# puxa a página que lista os links para os CSVs
html <- read_html(paste0(base.url,stat.list))

# Nesta página obtem a url das páginas
html %>%
  html_nodes(".heading") %>%
  html_attr("href") %>%
  na.omit() %>%
  paste0(base.url, .) -> page

# obtem os nomes de cada um dos CSVs
html %>%
  html_nodes(".heading") %>%
  html_attr("title") %>%
  na.omit() -> title

# monta um data.frame com os links encontrados
tibble( title, page ) %>%
  filter(grepl("ocorrencias.+", title)) -> stat.pages

# para cada url encontrada...
stat.pages$page %>%
  map(function(url){
    #  faz o fetch da página
    read_html(url) %>%
      # obtem o link do CSV
      html_node("p.muted a") %>%
      html_attr("href")    
  }) %>% 
  unlist() -> csv.link

# Adiciona o link ao data.frame
stat.pages <- bind_cols(stat.pages, csv.link=csv.link)

# para cada link
stat.pages$csv.link %>%
  map(function(href){
    # faz o download e a leitura do CSV
    read.table(url(href), skip = 4, header = T, sep=";", stringsAsFactors = F) %>%
      mutate(Código.IBGE.Município = as.character(Código.IBGE.Município)) %>%
      as.tibble()
  }) %>%
  # o "map" volta uma lista de tibbles, nomeia cada item da lista com o titulo do link
  setNames(stat.pages$title) -> occ.cvs.downloaded

# take a look in one of tibbles
head(occ.cvs.downloaded[[1]])
```


```{r occSaveBuffer, cache=TRUE, echo=FALSE}
if (exists("occ.cvs.downloaded")) {
  saveRDS(occ.cvs.downloaded,"./data/occ_csv_download.rds")
} else {
  occ.cvs.downloaded <- readRDS("./data/occ_csv_download.rds")
}
```

Com a lista de data frames de ocorrencias por ano em mãos, vamos fundir as informações a justar o header e os tipos das colunas.

```{r occColumntype, cache=TRUE}
# lista de tibbles
occ.cvs.downloaded %>%
  # funde em um unico dataframe
  bind_rows(.id = "dataset") %>% 
  # converte dados para fator (temporariamente)
  mutate_if(is.character, as.factor) %>%
  # transforma o "mes" em uma data
  mutate( month = dmy(paste0("01/",`Mês.Ano`)) ) %>%
  # ajusta nomes do header
  setNames(c("fonte","regiao","UF","estado","cod.ibge","municipio",
             "crime","mes","mes.ano","ocorrencias","data")) %>%
  # corrige as tipagens do codigo e do numero de ocorrencias
  mutate( cod.ibge = as.integer(as.character(cod.ibge)),
          ocorrencias = as.integer(ocorrencias)) -> occ

# dando uma olhada
head(occ)
```

Podemos observar que o `cod.ibge` é uma chave comum entre os dois datasets, o que facilitará o cruzamento de dados de população e ocorrências policiais.

## Vizualizando os dados

### População

Vamos visualizar alguns dos dados de população disponíveis (municípios com maior população).

```{r vizPopData, fig.width=10, fig.align="center"}

# selecionando municipios mais populosos
pop %>%
  # pega informacao mais recente dos municipios
  filter( date == max(date),
          nivel == "MU",
          cod.ibge != 5300108 ) %>%
  # seleciona os mais populosos
  top_n( 12, populacao ) %>%
  arrange( desc(populacao) ) %>%
  # codigo e nome
  select( cod.ibge ) -> top.pop.mun

pop %>%
  filter(date >= ymd("20070101")) %>%
  inner_join(top.pop.mun, by="cod.ibge") %>%
  # plota
  ggplot(aes(date,populacao)) +
    geom_line(aes(colour=municipio)) +
    geom_point(aes(colour=municipio)) +
    facet_wrap(~municipio) +
    theme(legend.position="none")

```

São medidas anuais, aparentemente consistentes e, com excessão de 2011, os dados estão presentes lá.

### Ocorrências

Já os dados de ocorrência, não parecem assim tão consistentes.

```{r vizOccData, fig.width=10, fig.align="center"}

# Visualizando ocorrencias
occ %>%
  # pega os ultimos 10 anos de dados
  filter(data>=ymd("20070101")) %>%
  # somente os mais populosos
  inner_join(top.pop.mun, by="cod.ibge") %>%
  select(cod.ibge, municipio, crime, date=data, ocorrencias) %>%
  # agrupa por data
  group_by(cod.ibge, municipio, date) %>%
  # somando os crimes
  summarise( ocorrencias = sum(ocorrencias, na.rm = T)) %>%
  # plota
  ggplot(aes(date,ocorrencias)) +
    geom_point(aes(colour=municipio)) +
    stat_smooth(aes(colour=municipio), method = "loess") +
    facet_wrap(~municipio) +
    theme(legend.position="none")

  
```


Nos municípios de maior população os dados não são completos, há gaps ou simplesmente param em uma certa data. Salvador, por exemplo só tem dado até 2014. Há alguns degraus, por exemplo, Rio de Janeiro, entre de 2010 e 2014, parece estar "saltado" mostrando uma descontinuidade não natural. Os dados de Belo Horizonte, estão praticamente zerados antes de 2010, o que pode indicar que os dados de segurança, disponibilizados no site do MJSP, não são muito confiáveis.

Além disso, aparentemente só alguns tipos de crime foram tabulados, pois a categorização se retringe somente a 6 tipos. 

```{r tipoOcorrencias}
# quais os tipos de ocorrencias
occ %>%
  filter( data >= ymd("20100101")) %>%
  mutate( ano = year(data))  %>%
  group_by(ano, crime) %>%
  summarise(total = sum(ocorrencias, na.rm = T)) %>%
  spread(ano, total)

```


## Calculando taxas de violência

### Interpolando os dados

Os dados de indicadores de criminalidade obtitos no site do MJSP são de base mensal enquanto os de população obtido no IBGE são anuais. Se quisermos obter as taxas de criminalidade precisamos colocar sob a mesma base de cálculo.

Como as taxas de população são mais estáveis, vamos interpolar, mês-à-mês, os dados populacionais entre um ano e outro. Usaremos a função [`na.approx`](https://www.rdocumentation.org/packages/zoo/versions/1.8-1/topics/na.approx) do pacote [`Zoo`](https://cran.r-project.org/web/packages/zoo/vignettes/zoo-quickref.pdf) para fazer uma interpolação linear dos pontos faltante. 

```{r interPop}
# declara a na.approx para interpolacao de valores
library(zoo)

# funcao apra interpolar date x population por mes.
interPopByMonth <- function(dtf=.){
  dtf %>%
    as.tibble() %>%
    # caso o registro ja tenha dados vazios
    filter(!is.na(populacao)) %>%
    # cria um tibble indo da menor data a maior data mes a mes e faz join
    right_join(
        tibble(date=seq.Date(from=min(.$date),to=max(.$date),by="month")),
        by="date") %>%
    # ordena por data
    arrange(date) %>%
    # interpola linearmente e reconstroi ano
    mutate( populacao = as.integer(round(na.approx(populacao))),
            ano = as.integer(year(date)) ) %>%
    return()
}

# a partir dos dados de populacao
pop %>%
  # para cada "municipio" agrupa os dados
  group_by(nivel, cod.ibge, municipio) %>%
  # em dataframes diferentes 
  nest() %>%
  # neste ponto os dataframes tem dados populacionais
  # anuais (datas de 01.dez.ANO), um data frame para cada municipio
  # passa esse dataframe para a funcao que interpola completando os dados
  mutate( data = data %>% map(interPopByMonth) ) %>%
  # recompoe a tabela 'desaninhando' os dataframes
  unnest() -> interp.pop

# visualizando
head(interp.pop)

```

### Computando as taxas

Agora com os dados populacionais em base mensal, podemos fazer a associação com as ocorrências.

```{r crimeRates}

# a partir das ocorrencias
occ %>%
  # agrupa por municipio e data
  group_by(cod.ibge, data) %>%
  # soma as ocorrencias (todos os tipos de crime)
  summarise( ocorrencias = sum(ocorrencias) ) %>%
  # adiciona a informacao de populcacao
  inner_join(interp.pop, by=c("cod.ibge","data"="date")) %>%
  # calcula a taxa em ocorrencias por 100 mil habitantes
  mutate( taxa = round(10^5 * ocorrencias / populacao, 2) ) %>%
  select( cod.ibge, municipio, ano, data, ocorrencias, populacao, taxa) -> crime.rates

# as 10 maiores taxas
head(crime.rates,10)

```

Vamos visualizar as taxas nas maiores cidades.

```{r vizCrimeRate}

crime.rates %>%
  inner_join(top.pop.mun, by="cod.ibge") %>%
  filter( data >= ymd("20100101") ) %>%
  # plota
  ggplot(aes(data,taxa)) +
    geom_point(aes(colour=municipio)) +
    stat_smooth(aes(colour=municipio), method = "loess") +
    facet_wrap(~municipio) +
    theme(legend.position="none")
  

```

